# CH4 : Encoding and evolution
- apps need to change over time and they need to be able to ***adapt***
- in most cases, ***change in app features lead to change in the data stored***
	- this can be a new field or record type or existing data needs to be presented in a new way
- dm have different ways of coping with such change
	- rdb enforces ***one*** schema at any point in time
		- in other words, at any point in time there ***will not be multiple schemas for the same data***
		- this one schema can be ***changed over time*** using schema migration(ALTER statements)
	- ddb do not enforce a schema
		- db can contain a mixture of older and newer data formats written at different times
- often if there is a change to the data, app code needs to change
	- in large app, changes often ***cannot happen instantaneously***
		- with server-side applications we may want to perform ***rolling upgrade***(staged rollout)
			- deploy the new version to a few nodes at a time
			- checking whether the new version is running smoothly
			- ***encourages*** frequent releases and better evolvability
				- by ***decreasing service downtime***
		- with client-side app, we are at the mercy of the user
			- they might not install the update for some time
- ***old and new versions of the code and the data formats might coexist at the same time***
	- in order for the system to continue running smoothly we need to maintain ***compatibility in both directions***:
		- ***backward compatibility***
			- newer code can read data that was written by older code
		- ***forward compatibility***
			- older code can read data that was written by newer code
- backward compatibility: not hard to achieve
	- we know the format of data written by older code
	- we can handle it explicitly(even by ***keeping the old code to read the old data***)
- forward compatibility is trickier
	- requires older code to ***ignore the additions*** made by a newer version of code

- what is the need for encoding? ^^^^ [[Designing Data intensive applications/Mar/Week5/28#formats for encoding data|ans]]
- what are the several formats for encoding data? ^^^^
	- JSON, XML, Protocol Buffers, Thrift, Avro
- How these formats handle schema changes? ^^^^
- how these formats support systems where old and new data and code need to coexist? ^^^^
- how these formats are used for data storage and for comms: in web services?^^^^
## formats for encoding data
- programs usually work with data in (at least) two different repr:
	- ***in mem, data is kept in objects***, structs, lists, arrays etc
		- these data structures are ***optimized for efficient access and manipulation by the CPU*** (typically using pointers)
	- ***for writing or transfer***, we have to encode data as some kind of ***self-contained sequence of bytes***
		- self-contained here means the ***bytes contain the data*** themselves and not a pointer
		- the sequence-of-bytes representation ***looks different*** from the data structures that are normally used in mem
			- exceptions: memory-mapped files or when operating directly on compressed data
- since different operations might need to be chained together to achieve desired op, each operation might ***need the data in a different representation***
- for this purpose we need a ***translation*** bw the two repr
- the translation from the in-mem repr to a byte sequence is called ***encoding***(aka serialization or marshalling)
- the translation from a byte sequence to in-mem repr is called ***decoding***(aka deser or unmarshalling)
- Serialization is also used in the context of transactions ~~~~
	- hence the term ***encoding*** will be used in this book to denote the above translation
- translation is a common problem and there are different libs and encoding formats to choose from

### Language-specific formats
- many PL come with built-in support for encoding
	- ex: Java - Serializable, Py - pickle
- these libs help us do the translation with minimal code
- there are problems with encoding libs:
	- ***encoding is often tied to the prog langs***
		- reading the data encoded by one lang is difficult in some other lang
		- using a pl's encoding means we are ***committing ourself to our current pl*** for a long time
		- ***integration of systems become difficult***
			- as each sys might not use the same lang