- how insert operations happen in btree?^^^^
- in btrees, are the ranges are predetermined or is it figured out as we go?^^^^
### Making BTrees reliable
- LSM-trees do not modify records in place
- the basic write operation of a BTree is to ***overwrite a page*** on disk with new data
	- for insertion, updation and deletion
	- ***overwrite does not change the location of the page***
		- all references to the overwritten page remain intact
- some operations require several pages to be overwritten
	- ex: splitting of a page during insertion because it is full
		- this requires write of two child pages, overwrite parent to point to two child pages
	- ***several overwrites are complicated because*** they might produce ***orphan pages*** if the db crashes in the middle of the operations
		- especially if new pages are created in this process
		- overwrites in general may lead to inconsistencies in case of crashes
	- orphan pages = none of the other pages point to this page
		- a page with now parent page
- in order to make the db resilient to crashes, BTree implementations include additional ds called ***Write-ahead log***(aka redo log)
	- again log here means append only file
	- every Btree modification is written to this ***append only file*** before it is applied to the pages of the tree itself
	- when the db comes back up, this file is used to restore consistent state
	- if there is a crash while writing to this WAL, then the operation will not even take place once the db is back up
	- ***appends, upto a certain size are atomic***
	- so any partial write to this file should be ignored to be on the safer side
- updating pages in-place needs proper ***concurrency control***
	- [concurrency control]([Concurrency Control in DBMS - GeeksforGeeks](https://www.geeksforgeeks.org/concurrency-control-in-dbms/))
		- is a concept that ***ensures consistency*** when multiple simultaneous manipulation of data takes place
		- cc has some protocols to solve concurrent txn problems
		- ***two protocols***: lock based and timestamp based
	- in btree cc is done by protecting the tree's ds with ***latches***(light weight locks)
- ***lock based protocol***:
	- ***each txn needs to get locks*** b4 they start accessing or modifying the data items
	- two types of locks:
		- ***shared lock***: aka read lock which allows multiple txns to read the data simultaneously
			- shared lock can be used only to read but not to write
		- ***exclusive lock***: aka write lock
			- allows updation as well
			- ***only one txn*** can hold exclusive lock on a data item at a time
			- no other txn is allowed to acquire a ***shared or exclusive lock*** on the ***same data item***
	- there are two ***lock based protocols***
		- I think the following determines how the locks are acquired and released
		- two phase locking protocol
		- strict two phase locking protocol
- timestamp based protocol
	- each txn has a ***timestamp*** attached to it
	- timestamp is a ***unique identifier*** created by the DBMS
	- the timestamps are assigned on the order in the which the txns are submitted to the system
	- conflicting pairs of operations are resolved with timestamps of the txn

### B-Tree optimizations
- some optimizations developed over the years
	- instead of overwriting pages and maintaining a WAL for crash recovery, some dbs use a ***copy-on-write scheme***
		- a modified page is written to a diff location and a new version of the ***parent pages*** in the tree is created
			- the new parent points to the new location of the child
			- useful for concurrency control: Snapshot isolation and repeatable read ~~~~
	- ***store abbreviations of the keys*** instead of the entire key
		- saves space
		- abbreviate until it is small enough and serves information on boundaries at the same time 
		- allows us to store multiple such keys on the same level, allows higher bf and decreases num of levels
			- this is advantageous as a page is a block of data that is stored continuously
			- if the bf is higher, we do not have to search in multiple pages for certain keys: [[07#^64f9db|effect of bf]]
				- usually we might have to visit the parent page to get the reference of the next page that we need to search in
	- position ***leaf pages in sequential order in disk*** ^64f9db
		- in general, pages can be positioned ***anywhere*** on disk
			- no particular rule to place them nearby on disk
			- if a query needs to scan over a large part of the key range in sorted order, the original layout causes disk seeks for every page that is read
			- this is why storing sequentially works
			- 
		- difficult to maintain the order as the tree grows
		- in LSMT it is easier as the merging takes care of the same in one go and similar records are stored nearby
	- ***additional pointers are added to the leaf pages***
		- these pointers are references to sibling pages to the left and right
		- allows scanning in order without having to jump back to the parent pages for references
	- fractal trees(variant of BT) borrow log-structured ideas to reduce disk seeks
		- not explained in book
