- leveled compaction is complex
- ***sstable = disk file format***
- leveled compaction
	- sets the first segment that is written to the disk to be in level 0
	- everything in level 0 will ***eventually*** get promoted to higher levels
	- there is ***a max sstable*** size that applies for all levels
		- each sstable is 160Mb by default
	- ***each level has a size***
		- each level is typically ***10x the size of the previous level***
		- this ***level size*** is a ***multiple of max sstable size*** as well
	- when the max size for a level is exceeded, a compaction is triggered and a new level is created
		- files are moved to the next high level until the current level's size is not exceeded
	- looked like the highest level in the system will have the smallest(in terms of value) keys


## B-Trees
- most widely used ***indexing structure***
- ***std index implementation*** in almost all rdbs, many non-rdb use them too
- only similarities with SST:
	- b-trees keep kvp ***sorted*** by key
		- allows for efficient ***kv lookups*** and ***range queries***
- other than above, very different design than SST
- ***disks*** are arranged in ***fixed size blocks***
- btree design corresponds more closely to underlying hw
	- how?
		- btrees break the db down into ***fixed-size blocks or pages***
			- traditionally 4 kb in size(sometimes bigger)
			- reads and writes one page at a time
				- I guess this might not be sequential in disk, hence random
- whereas in log-structured indexes: 
	- db broken down into variable-sized segments
		- isn't there a threshold after which a segment is closed and a new one is started? ^^^^
			- yes initially the segments can be identical in size
			- but as compaction and merging kicks in, I think the files may not be same in size all the time
	- always write a segment sequentially
- each page can be identified using an address or location
	- ***this does not mean a page is only address***
	- allows one page to refer to another
		- similar to pointer, but on disk instead of mem
	- these page references can be used to construct a tree of pages
![[Pasted image 20240305191805.png]]
- one page is designated as the ***root*** of the btree
	- we start from here, when we want to lookup a key
- the root page consists of ***several keys and references*** to ***child pages***
- each child page is ***responsible for a continuous range of keys***
	- for example, the lhs child page is responsible for the range 100 to 199
- the keys bw the references indicate where the boundaries bw those ranges lie
- the tree grows till we reach to a page, ***containing only individual keys***, called ***leaf page***
	- leaf page either contains the ***value for each key inline*** or ***references to*** the pages where the values can be found
- the ***number of references to child pages*** in each page of the BTree is called the ***branching factor***
	- are branching factor pre-determined?^^^^
		- yes they can be, if we know the pointer size and the key size
	- in the above diag, notice that every page has a branching factor of 6
	- obviously this does not apply to the leaf page: check the leaf above
- branching factor ***depends*** on the amount of space required to store the page references and the range boundaries within the page size
	- i believe the lesser space required to store page references, more the Bf
	- typically several hundred
	- bf depends on data
- does this not look like binary search?
- B-Tree means balanced tree
- if we want to update the value of an existing key %%%%
	- we search for the leaf page containing that key, change the value in that page and write the page back to the disk
- if we want to add a new key, we need to find the page whose range contains the new key and add it to that page %%%%
	- if there isn't enough free space in the page to accommodate the new key, it is split into two half-full pages and the parent is updated to account for the new subdivision
		- does this mean the parent now will be pointing to two pages or is a key chose to be placed in the parent and space is made for the two child pages on either side of the key
			- remember the key indicates a boundary and it does not contain the value on each page
			- both of the approaches increases the bf
	- #check
- a btree with n keys always has a depth of O(log n)
- how about deleting?^^^^
	- I think deleting should be fairly easy
	- find the leaf page that contains the kvp that needs to be deleted and overwrite the page without the key
	- are the pages merged ^^^^?
		- I feel this is unlikely because the space needs to be there for the likely event of the deleted key being added again
- what indicates absence of a reference in the pages? ^^^^
	- in other words what indicates free slot for reference in a page?
