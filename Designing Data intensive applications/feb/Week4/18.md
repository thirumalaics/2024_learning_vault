#### NW model
- CODASYL model
- generalization of the hierarchical model
- hm: in the tree structure, every record has one parent
- nwm: a record could have many parents
	- ex: there could be one record for ASE and all who attend(ed) can be linked to it
		- here the ASE college record is the child record referred by the alum records
	- allowed MTO and MTM to be modeled
- the links bw the records were not established by fks 
	- structure similar to pointers in a programming language is used(while still being stored on disk)
- the only way of accessing a record was to follow a path from a root along these chains of links
	- called access path
- in the simplest case, an access path could be like the traversal of a linked list
- but due to existence of MTM, several different paths can lead to the same record
- a programmer working with the nwm had to keep track of these different access paths in their head or code
- a query was performed by moving a cursor through the db by iterating over lists of records and following access paths
	- if a record has many incoming pointers from other records, the app code had to keep track of all the various relationships
- the result of the above is inflexible complex code for querying and updating
- if we do not know the path to the record we are looking for, it is a difficult situation
	- hm and nwm
	- we can change the access path and this requires code change
- difficult to modify app dm
#### relational model
- in rdbms, the query optimizer automatically decides which parts of the query to execute in which order, and which indexes to use
	- these choices can be seen as similar to access paths
	- these choices are made automatic
- when we want to query our data in new ways, we need to declare new index
	- queries automatically use the index that is most appropriate
	- queries do not change in order to leverage new index
	- this made it much easier to add new features to apps
- design of query optimizer benefits in the long run than opting to hand-code access paths for better query performance
#### comparison to document dbs
- DDBs store nested records within their parent record, similar to hierarchical model
- in terms of representing MTO and MTM relationships, relational and document dbs use a unique identifier aka fk in the RM and ***document reference*** in the DocM
	- the identifier is resolved at query time using joins or follow-up queries
### Relational v DDBs today
- they differ in ***fault-tolerance*** properties and ***concurrence handling*** among others
- wrt data model:
	- DDM: schema flexibility, better performance due to data locality and similarities with data structures of some applications
	- RM: better support for Joins, MTO and MTM
	- it is better to use DDM if our ***app data*** has document-like structure
		- doc-like structure - tree of OTM Rls, where typically the ***entire tree is loaded at once***
		- when this is the case, the relational technique of ***shredding*** - splitting a document-like structure into multiple tables can lead to complex code and schemas
		- limitations: we cannot ***directly*** refer to a nested item within a document, we have to go like "2nd item in the list of X for user Y"
			- looks similar to the access path in the hierarchical model
			- this can get complicated if the docs are deeply nested
		- depending on our app, the weak support for joins might become a problem
			- the need for join can be minimalized by ***denormalization***, but that comes with the cost where the code keeps the data consistent
			- joins can also be eliminated by making multiple calls to the db, but that too pushes the complexity to the code rather than a centralized engine that can perform join efficiently
		- for highly connected data, RM is acceptable and Graph models are natural