### rdb v ddbs compared contd.
- schema flexibility in the doc model
	- most ddbs do not enforce any schema on the data in documents
	- 'JSON support in RDBMS' as well usually does not enforce any schema on the data in documents
	- XML support in RDB usually comes with optional schema validation
	- arbitrary keys and values can be added to the doc
	- doc dbs are sometimes called schemaless
		- misleading, as the ***code*** that reads the data usually assumes ***some*** kind of structure
		- the term means: there is an implicit structure, but the db does not enforce it
	- more accurate term for ddbs is ***schema-on-read***
		- structure of the data is implicit and only interpreted when the data is read
		- opposite to schema-on-write: traditional approach
			- schema is explicit and the ***db ensures*** all written data ***conforms*** to it
	- schema-on-read similar to dynamic(runtime) type checking in programming language
	- schema-on-write is similar to static(compile-time) type checking
	- difference between the two approaches is noticeable in situations where an app wants to change the format of its data
		- ex: currently we are storing the users' full name in one field and the change requires the names to be separately stored
		- in doc db, we just start writing it in such way for new records
		- changes are mostly no-effort
			- while the code has to be able to handle new and old cases
		- in RDB, a migration happens
			- ![[Pasted image 20240219183451.png]]
			- schema changes(ALTER TABLE) are considered slow and requiring downtime
				- but this might not be true for many dbs
				- in MYSQL, it takes more time than in other dbs
			- however, the update statement is going to take much time on big databases and large tables
				- one way to forgo update is to set it to null and write/handle it at read time like ddb
	- schema on read is for ***heterogenous*** data
		- where all data items do not have the same structure, it is either because
			- we have different types of objects and it is not possible to put each one in its own table
			- the structure of the data is determined by external systems over which we have no control and which may change at any time
#### data locality for queries
- ***a document*** is usually stored as a single continuous string, encoded as JSON, XML or a binary variant
- if our app ***often*** requires ***access to the entire/large part of doc***, nosql might be the most efficient
	- ex: webpage content
	- in RDB, it requires multiple lookups and this might slow down the entire retrieval
- locality advantage only applies if we need large parts of the document at the ***same time***
- db typically ***loads the entire doc***, even if we access only a small portion of it
- updates usually require the ***entire doc to be re-written***
	- only mods that do not change the encoded size of the doc can easily be performed in place ^^^^
		- I found that this behavior has a workaround
		- I was not able to find what changes dont affect encoded size
	- reccos: keep the doc size fairly small and avoid writes that increase the size of the doc
		- when doc size is small, the re-write becomes less heavy
- these performance limitations restrict the domain of ddbs
- grouping related data together for locality is not limited to doc model
	- google's spanner db offers the same locality properties in a RM
		- by allowing the schema to declare that a table's rows should be interleaved(nested) within a parent table ^^^^
	- oracle with multi-table index cluster tables ^^^^
		- table cluster: group of tables that share common columns and store related data in the same blocks
		- single data block can contain rows from multiple tables
	- column-family in BT
#### convergence of document and relational dbs
- most rdbs except MySQL have supported XML since 2000s
	- includes
		- mods to XMLs
		- indexing and querying inside XML docs
	- this allows apps to use dm similar to ddm
- similar level of support for JSON is provided my many RDBs
- ddbs side, support for relational-like joins are seen in some
	- in some dbs, doc references are resolved and joins performed in the client side
		- likely slower than a join in server side due to nw round trips
