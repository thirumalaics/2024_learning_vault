- data model refers to the way data is organized, documented and defined within a database
## RM v Document Model
- RM
	- relations, tuples
	- the use cases of RM are txn processing(entering txns) and batch processing(customer invoicing, payroll)
		- txn processing is information processing in general
			- it is called information processing because the processing is divided into indivisible individual operations called transactions
			- each txn must succeed or fail as a complete unit
			- usually performed as a real-world activity takes place
			- usually short running times
		- batch processing also is information processing that acts on the data written by transaction processing
			- performed off-peak time
			- automated routing processing
			- huge running times
	- other dbs(hierarchical and nw) at that time forced app developers to think a lot about the internal representation of the data in db
		- RM hid the implementation details behind a cleaner interface
	- RM survived and won over Object dbs, XML dbs
	- RM was later used for diverse purposes and it generalized very well
		- beyond the original scope of business data processing
### Birth of NoSQL
- appeared first in 2010s
- driving forces behind the adoption of NoSQL dbs:
	- need for greater scalability than rdb can easily achieve, including very large datasets or very high write throughput
	- preference for free and opensource sw over commercial db products
	- specialized query operations that are not well supported by the rm
		- desire for dynamic and expressive data model
- diff apps diff requirements
	- so diff choice of tech
#### Object relational mismatch
- most app dev today in oop lang
- one common criticism of RM from oop is the requirement of an awkward translation layer
	- this translation layer operates bw the objects in app code and rdb structures(row, cols and tables)
	- the disconnect bw the models is sometimes called an ***impedance mismatch***
- Object relational mapping fws reduce the amount of boiler plate code required for translation layer, but they cannot hide the differences bw the two models
- how one-to-many relationships can be stored:
	- in traditional sql model, put the many side in different tables with a fk reference to the one side
	- later versions of SQL std added support for structured datatypes and xml data
		- allowed multivalued data to be stored within a single row, with support for querying and indexing inside the docs
	- encode the many side as JSON or XML doc and store it as a text col in db
		- let the app interpret its structure and content
		- db cannot query for values inside that encoded column
- JSON data model is supported by MongoDB, CouchDb etc
- some devs feel that JSON model reduces the impedance mismatch bw the app code and the storage layer
	- but there are problems with JSON as a data encoding format [[CH4]]
- json has better locality than the multi-table schema
	- ex: if we need to fetch a profile in the relational example, we need to perform multi-way joins bw users and its subordinate tables
	- In json repr, all the relevant information is in one place, and one query is sufficient
### Many-to-one and Many-to-Many relationships
- ![[Pasted image 20240217120437.png]]
- why not store the region and industry as actual texts rather than having IDs above
	- consistent style and spelling across profiles
	- avoiding ambiguity(different cities named the same)
	- ease of updating
	- localization support
		- because the actual values are standardized and stored separately, translation becomes easier due to standard values
	- better search
	- basically to avoid inconsistencies and anomalies
	- but doesn't this make json model to require joins
		- yes
	- in ddbs, joins are not needed for one-to-many tree structures, and support for joins is often weak
- join support in nosql dbs are weak
	- one reason for denormalization
	- we have to emulate join in application code by making multiple queries to db
		- making the join shifts from the db to the app code
- even if the initial version of the app fits well in a join-free document model, data has a tendency of becoming more interconnected as features are added to applications
	- we will have to start storing references to other docs instead of storing plain values at some point
	- check 57-58 PDf pages
- hierarchical model has remarkable similarities to the JSON model
	- represented all data as a tree of records nested within records like JSON
	- HM faced similar problem to JSON, deals with OTM well but MTM difficult and it did not support joins
	- devs needed to deccide whether to duplicate data or manually resolve references from one record to another