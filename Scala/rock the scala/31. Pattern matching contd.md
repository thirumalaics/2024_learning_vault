- only Any type expression can be pattern matched with other types
	- remember when I tried to patter match a String variable with other data types, I got a compilation error
```
val x: Any = "String"  
println(x match {  
  case 1 => "A number"  
  case true => "The truth"  
  case "String" => "A String"  
  case pattermatchcontd => "A singleton object"  
})
```
- to match anything, one way to do is to use wildcard
	- the wildcard he has been using is \_
	- the inferred type for the following variable is Unit
```
val matchAnything = x match {
case _ => 
}
```
- another way to match anything is to use variable
	- the variable then can be used as part of result that we return, which is not possible with underscore
		- `case _ => s"I have found ${_}"` // errors out
```
val matchAvariable = x match {
	case something => s"I have found $something"
	case _ => "whatever" // never reached
}
```
- pattern matching is also possible with tuples and other simple data structures
```
val aTuple = (1,23)
val matchATuple = aTuple match {
	case (1,1) => 
	case (something, 23) => s"hey I found $something along with 23"
}
```
- nested pattern matching
```
aNestedTuple match {  
  case (_, (something1, something2)) => s"I found $something1 $something2"  
  case (_, (something1, (something2, 1))) => s"I found all this $something1 $something2"  
}
```
- following pattern is called constructor pattern:
```
val aList: MyList[Int] = Cons(1,Cons(2, Empty))
val matchAList = aList match {
	case Empty => s"Hey the list is empty"
	case Cons(head, Cons(subhead, subtail)) => s"My nestedd list looks like $head , $subhead , $subtail"
}
```
- to import a class 